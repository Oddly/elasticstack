# Ansible
#
# Rolling Upgrade of Elasticsearch with security on
# Source from: author: Jeff Steinmetz, @jeffsteinmetz; Bin Li, @holysoros
# Modifications: author: Daniel Neuberger @netways.de
# More modifications: NETWAYS Professional Services GmbH
# latest tested with Ansible 2.9 and later

---

# For now we support upgrade only for clusters with security enabled
# If you positively need support for safely upgrading clusters without security,
# feel free to open an issue at https://github.com/Oddly/ansible-collection-elasticstack/issues
- name: Set connection protocol to https
  ansible.builtin.set_fact:
    elasticsearch_http_protocol: "https"

- name: Check for running Elasticsearch service
  ansible.builtin.systemd:
    name: elasticsearch
  register: elasticsearch_running

- name: Update stopped services right away
  when:
    - elasticsearch_running.status.ActiveState == "inactive"
  block:
    - name: Update stopped Elasticsearch - rpm with managed repositories
      ansible.builtin.package:
        name: "{{ elasticsearch_package }}"
        enablerepo:
          - 'elastic-{{ elasticstack_release }}.x'
      when:
        - ansible_os_family == "RedHat"
        - elasticstack_full_stack | bool

    - name: Update stopped Elasticsearch - deb or unmanaged repositories rpm
      ansible.builtin.package:
        name: "{{ elasticsearch_package }}"
      when:
        - ansible_os_family == "Debian" or
          not elasticstack_full_stack | bool

- name: Update single instances without extra caution
  when:
    - groups[elasticstack_elasticsearch_group_name] | length == 1
  block:
    - name: Update single instances without extra caution - deb or unmanaged repositories rpm
      ansible.builtin.package:
        name: "{{ elasticsearch_package }}"
      when:
        - ansible_os_family == "Debian" or
          not elasticstack_full_stack | bool
      notify:
        - Restart Elasticsearch

    - name: Update single instances without extra caution - rpm with managed repositories
      ansible.builtin.package:
        name: "{{ elasticsearch_package }}"
        enablerepo:
          - 'elastic-{{ elasticstack_release }}.x'
      when:
        - ansible_os_family == "RedHat"
        - elasticstack_full_stack | bool
      notify:
        - Restart Elasticsearch


- name: Be careful about upgrade when Elasticsearch is running
  when:
    - elasticsearch_running.status.ActiveState == "active"
    - groups[elasticstack_elasticsearch_group_name] | length > 1
  block:

    # After a previous node's upgrade, the local ES instance may need time to
    # re-discover the master (e.g. during 8.xâ†’9.x rolling upgrades). Wait for
    # the cluster API to respond with 200 before attempting any cluster operations.
    - name: Wait for Elasticsearch cluster API to be responsive
      ansible.builtin.uri:
        url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}/_cluster/health"
        method: GET
        user: elastic
        password: "{{ elasticstack_password.stdout }}"
        validate_certs: false
        status_code: [200, 503]
      register: _es_responsive
      until: (_es_responsive.status | default(0)) == 200
      retries: 30
      delay: 10
      no_log: "{{ elasticstack_no_log }}"

    # Usually we should not need this step. It's only there to recover from broken upgrade plays
    # Without this step the cluster would never recover and the play would always fail
    - name: Enable shard allocation for the cluster
      ansible.builtin.uri:
        url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}/_cluster/settings"
        method: PUT
        body: '{ "persistent": { "cluster.routing.allocation.enable": null }}'
        body_format: json
        user: elastic
        password: "{{ elasticstack_password.stdout }}"
        validate_certs: false
      register: response
      until: response.json.acknowledged | default(false)
      retries: 10
      delay: 30

    # Relax disk watermarks so shards can allocate even on near-full disks
    # (common in CI/Docker). Without this, .security-7 replicas stay
    # unassigned and auth breaks after a node restart.
    - name: Set lenient disk watermarks for rolling upgrade
      ansible.builtin.uri:
        url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}/_cluster/settings"
        method: PUT
        body:
          persistent:
            cluster.routing.allocation.disk.watermark.low: "97%"
            cluster.routing.allocation.disk.watermark.high: "98%"
            cluster.routing.allocation.disk.watermark.flood_stage: "99%"
            cluster.routing.allocation.disk.watermark.flood_stage.frozen: "99%"
        body_format: json
        user: elastic
        password: "{{ elasticstack_password.stdout }}"
        validate_certs: false
      register: watermark_response
      until: watermark_response.json.acknowledged | default(false)
      retries: 5
      delay: 10

      # this step is key!!!  Don't restart more nodes
      # until all shards have completed recovery
    - name: Wait for cluster health to return to green
      ansible.builtin.uri:
        url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}/_cluster/health"
        method: GET
        user: elastic
        password: "{{ elasticstack_password.stdout }}"
        validate_certs: false
      register: response
      until: (response.json.status | default('')) in ['green', 'yellow']
      retries: 50
      delay: 30

    # Disabling shard allocation right after enabling it seems redundant. Please see above for details.
    - name: Disable shard allocation for the cluster
      ansible.builtin.uri:
        url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}/_cluster/settings"
        method: PUT
        body: '{ "persistent": { "cluster.routing.allocation.enable": "none" }}'
        body_format: json
        user: elastic
        password: "{{ elasticstack_password.stdout }}"
        validate_certs: false
      register: response
      until: response.json.acknowledged | default(false)
      retries: 5
      delay: 10

    - name: Stop non essential indexing to speed up shard recovery
      ansible.builtin.uri:
        url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}/_flush"
        method: POST
        user: elastic
        password: "{{ elasticstack_password.stdout }}"
        validate_certs: false
      failed_when: false

    - name: Shutdown elasticsearch service
      ansible.builtin.service:
        name: elasticsearch
        enabled: true
        state: stopped
      when:
        - not elasticsearch_unsafe_upgrade_restart | bool

    - name: Update Elasticsearch - rpm with managed repositories
      ansible.builtin.package:
        name: "{{ elasticsearch_package }}"
        enablerepo:
          - 'elastic-{{ elasticstack_release }}.x'
      when:
        - ansible_os_family == "RedHat"
        - elasticstack_full_stack | bool

    - name: Update Elasticsearch - deb or unmanaged repositories rpm
      ansible.builtin.package:
        name: "{{ elasticsearch_package }}"
      when:
        - ansible_os_family == "Debian" or
          not elasticstack_full_stack | bool

    - name: Start elasticsearch
      ansible.builtin.service:
        name: elasticsearch
        enabled: true
        state: started
      when:
        - elasticsearch_running.status.ActiveState == "active"
        - not elasticsearch_unsafe_upgrade_restart | bool

    - name: Restart elasticsearch (fast, for non-prod)
      ansible.builtin.service:
        name: elasticsearch
        enabled: true
        state: restarted
      when:
        - elasticsearch_running.status.ActiveState == "active"
        - elasticsearch_unsafe_upgrade_restart | bool

    - name: Wait for elasticsearch node to come back up if it was stopped
      ansible.builtin.wait_for:
        host: "{{ elasticsearch_api_host }}"
        port: "{{ elasticstack_elasticsearch_http_port }}"
        delay: 30

    - name: Confirm the node joins the cluster
      ansible.builtin.uri:
        url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}/_cat/nodes?h=name"
        method: GET
        user: elastic
        password: "{{ elasticstack_password.stdout }}"
        validate_certs: false
        return_content: true
      register: result
      until: elasticsearch_nodename in (result.content | default('')).split()
      retries: 200
      delay: 3
      no_log: "{{ elasticstack_no_log }}"

    - name: Enable shard allocation for the cluster
      ansible.builtin.uri:
        url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}/_cluster/settings"
        method: PUT
        body: '{ "persistent": { "cluster.routing.allocation.enable": null }}'
        body_format: json
        user: elastic
        password: "{{ elasticstack_password.stdout }}"
        validate_certs: false
      register: response
      until: response.json.acknowledged | default(false)
      retries: 5
      delay: 30

    - name: Wait for cluster health to return to yellow or green
      ansible.builtin.uri:
        url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}/_cluster/health"
        method: GET
        user: elastic
        password: "{{ elasticstack_password.stdout }}"
        validate_certs: false
      register: response
      until: (response.json.status | default('')) in ['green', 'yellow']
      retries: 5
      delay: 30

    - name: Record that rolling upgrade performed its own restart
      ansible.builtin.set_fact:
        _elasticsearch_rolling_upgrade_performed: true
