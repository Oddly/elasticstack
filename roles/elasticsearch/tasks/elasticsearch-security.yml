---
# --- CA and certificate management (modular) ---
#
# This section uses shared task files from roles/elasticstack/tasks/certs/
# to handle CA creation, certificate generation, distribution, backup, and
# renewal. The modular files are reusable across elasticsearch, kibana,
# logstash, and beats roles.

# -- Check CA expiry on CA host --
- name: Check CA certificate expiry
  ansible.builtin.include_tasks:
    file: "{{ role_path }}/../elasticstack/tasks/certs/cert_check_expiry.yml"
    apply:
      tags:
        - certificates
        - renew_ca
  vars:
    _cert_path: "{{ elasticstack_ca_dir }}/elastic-stack-ca.p12"
    _cert_pass: "{{ elasticstack_ca_pass }}"
    _cert_buffer_days: "{{ elasticstack_ca_expiration_buffer }}"
    _cert_expiry_fact: elasticstack_ca_will_expire_soon
  when: inventory_hostname == elasticstack_ca_host
  tags:
    - certificates
    - renew_ca

# -- Stop Logstash for CA renewal (orchestration, kept inline) --
# Use default([]) + length > 0 for group checks (Ansible 2.20 compatibility)
- name: Stop Logstash
  ansible.builtin.service:
    name: logstash
    state: stopped
  with_items: "{{ groups[elasticstack_logstash_group_name] | default([]) }}"
  delegate_to: "{{ item }}"
  when:
    - "'renew_ca' in ansible_run_tags or elasticstack_ca_will_expire_soon | bool"
    - elasticstack_logstash_group_name is defined
    - groups[elasticstack_logstash_group_name] | default([]) | length > 0

# -- Backup CA directory on CA host --
- name: Backup CA directory on CA host
  ansible.builtin.include_tasks:
    file: "{{ role_path }}/../elasticstack/tasks/certs/cert_backup.yml"
    apply:
      tags:
        - renew_ca
  vars:
    _backup_path: "{{ elasticstack_ca_dir }}"
    _backup_target: "{{ inventory_hostname }}"
  when:
    - inventory_hostname == elasticstack_ca_host
    - "'renew_ca' in ansible_run_tags or elasticstack_ca_will_expire_soon | bool"
  tags:
    - renew_ca

# -- Backup CA cert on Ansible controller --
- name: Backup CA cert on Ansible controller
  ansible.builtin.include_tasks:
    file: "{{ role_path }}/../elasticstack/tasks/certs/cert_backup.yml"
    apply:
      tags:
        - renew_ca
  vars:
    _backup_path: "{{ lookup('config', 'DEFAULT_LOCAL_TMP') | dirname }}/ca.crt"
    _backup_target: localhost
    _backup_become: false
  when:
    - inventory_hostname == elasticstack_ca_host
    - "'renew_ca' in ansible_run_tags or elasticstack_ca_will_expire_soon | bool"
  tags:
    - renew_ca

# -- Check ES node certificate expiry --
- name: Check Elasticsearch certificate expiry
  ansible.builtin.include_tasks:
    file: "{{ role_path }}/../elasticstack/tasks/certs/cert_check_expiry.yml"
    apply:
      tags:
        - certificates
        - renew_es_cert
  vars:
    _cert_path: "/etc/elasticsearch/certs/{{ ansible_hostname }}.p12"
    _cert_pass: "{{ elasticsearch_tls_key_passphrase }}"
    _cert_buffer_days: "{{ elasticsearch_cert_expiration_buffer }}"
    _cert_expiry_fact: elasticsearch_cert_will_expire_soon
  tags:
    - certificates
    - renew_es_cert

# -- Backup ES certs on the node --
- name: Backup Elasticsearch certs on node
  ansible.builtin.include_tasks:
    file: "{{ role_path }}/../elasticstack/tasks/certs/cert_backup.yml"
    apply:
      tags:
        - renew_ca
        - renew_es_cert
  vars:
    _backup_path: /etc/elasticsearch/certs
    _backup_target: "{{ inventory_hostname }}"
  when: "'renew_es_cert' in ansible_run_tags or 'renew_ca' in ansible_run_tags or elasticsearch_cert_will_expire_soon | bool"
  tags:
    - renew_ca
    - renew_es_cert

# -- Backup ES cert on CA host --
- name: Backup Elasticsearch cert on CA host
  ansible.builtin.include_tasks:
    file: "{{ role_path }}/../elasticstack/tasks/certs/cert_backup.yml"
    apply:
      tags:
        - renew_ca
        - renew_es_cert
  vars:
    _backup_path: "{{ elasticstack_ca_dir }}/{{ ansible_hostname }}.p12"
    _backup_target: "{{ elasticstack_ca_host }}"
  when: "'renew_es_cert' in ansible_run_tags or 'renew_ca' in ansible_run_tags or elasticsearch_cert_will_expire_soon | bool"
  tags:
    - renew_ca
    - renew_es_cert

# -- Backup ES cert on Ansible controller --
- name: Backup Elasticsearch cert on Ansible controller
  ansible.builtin.include_tasks:
    file: "{{ role_path }}/../elasticstack/tasks/certs/cert_backup.yml"
    apply:
      tags:
        - renew_ca
        - renew_es_cert
  vars:
    _backup_path: "{{ lookup('config', 'DEFAULT_LOCAL_TMP') | dirname }}/{{ ansible_hostname }}.p12"
    _backup_target: localhost
    _backup_become: false
  when: "'renew_es_cert' in ansible_run_tags or 'renew_ca' in ansible_run_tags or elasticsearch_cert_will_expire_soon | bool"
  tags:
    - renew_ca
    - renew_es_cert

# -- Keystore setup (kept inline, import_tasks) --
- name: Import Tasks elasticsearch-keystore.yml
  ansible.builtin.import_tasks: elasticsearch-keystore.yml

# -- Create CA on CA host --
- name: Ensure CA exists on CA host
  ansible.builtin.include_tasks:
    file: "{{ role_path }}/../elasticstack/tasks/certs/ca_ensure.yml"
    apply:
      tags:
        - certificates
        - renew_ca
        - renew_es_cert
  when: inventory_hostname == elasticstack_ca_host
  tags:
    - certificates
    - renew_ca
    - renew_es_cert

# -- Generate node certificates on CA host --
- name: Generate Elasticsearch node certificate
  ansible.builtin.include_tasks:
    file: "{{ role_path }}/../elasticstack/tasks/certs/cert_generate.yml"
    apply:
      tags:
        - certificates
        - renew_ca
        - renew_es_cert
  vars:
    _cert_name: "{{ hostvars[item].ansible_hostname }}"
    _cert_ip: "{{ hostvars[item].ansible_default_ipv4.address | default(hostvars[item].ansible_all_ipv4_addresses[0]) }}"
    _cert_dns: "{{ hostvars[item].ansible_hostname }},{{ hostvars[item].ansible_fqdn }},{{ hostvars[item].inventory_hostname }}"
    _cert_out: "{{ elasticstack_ca_dir }}/{{ hostvars[item].ansible_hostname }}.p12"
    _cert_pass: "{{ (hostvars[item].elasticsearch_tls_key_passphrase is defined) | ternary(hostvars[item].elasticsearch_tls_key_passphrase, elasticsearch_tls_key_passphrase) }}"
    _cert_validity: "{{ elasticsearch_cert_validity_period }}"
  loop: "{{ groups[elasticstack_elasticsearch_group_name] }}"
  when: inventory_hostname == elasticstack_ca_host
  tags:
    - certificates
    - renew_ca
    - renew_es_cert

# -- Extract CA public certificate --
- name: Extract CA public certificate
  ansible.builtin.include_tasks:
    file: "{{ role_path }}/../elasticstack/tasks/certs/ca_extract_public.yml"
    apply:
      tags:
        - certificates
        - renew_ca
  vars:
    _cert_p12_path: "{{ elasticstack_ca_dir }}/{{ ansible_hostname }}.p12"
    _cert_ca_out: "{{ elasticstack_ca_dir }}/ca.crt"
    _cert_pass: "{{ elasticsearch_tls_key_passphrase }}"
  when: inventory_hostname == elasticstack_ca_host
  tags:
    - certificates
    - renew_ca

# -- Create ES certificate directory (ES-specific path/perms, kept inline) --
- name: Create certificate directory
  ansible.builtin.file:
    state: directory
    path: /etc/elasticsearch/certs
    owner: root
    group: elasticsearch
    mode: 0750
  tags:
    - certificates
    - renew_ca
    - renew_es_cert

# -- Distribute CA certificate to ES nodes --
- name: Distribute CA certificate to Elasticsearch nodes
  ansible.builtin.include_tasks:
    file: "{{ role_path }}/../elasticstack/tasks/certs/cert_distribute.yml"
    apply:
      tags:
        - certificates
        - renew_ca
        - renew_es_cert
  vars:
    _cert_src: "{{ elasticstack_ca_dir }}/ca.crt"
    _cert_dest: /etc/elasticsearch/certs/ca.crt
    _cert_owner: root
    _cert_group: elasticsearch
    _cert_mode: "0640"
    _cert_notify:
      - Restart Elasticsearch
      - Restart kibana if available for elasticsearch certificates
  tags:
    - certificates
    - renew_ca
    - renew_es_cert

# -- Distribute node certificate to ES nodes --
- name: Distribute node certificate to Elasticsearch nodes
  ansible.builtin.include_tasks:
    file: "{{ role_path }}/../elasticstack/tasks/certs/cert_distribute.yml"
    apply:
      tags:
        - certificates
        - renew_ca
        - renew_es_cert
  vars:
    _cert_src: "{{ elasticstack_ca_dir }}/{{ ansible_hostname }}.p12"
    _cert_dest: "/etc/elasticsearch/certs/{{ ansible_hostname }}.p12"
    _cert_owner: root
    _cert_group: elasticsearch
    _cert_mode: "0640"
    _cert_notify:
      - Restart Elasticsearch
      - Restart kibana if available for elasticsearch certificates
  tags:
    - certificates
    - renew_ca
    - renew_es_cert

- name: Start Elasticsearch for security tasks
  ansible.builtin.service:
    name: elasticsearch
    state: started
    enabled: yes
  register: elasticsearch_freshstart_security

- name: Wait for all instances to start
  ansible.builtin.include_tasks: wait_for_instance.yml
  loop: "{{ groups[elasticstack_elasticsearch_group_name] }}"

- name: Restart if Elasticsearch was already running
  when:
    - not elasticsearch_freshstart.changed | bool
    - not elasticsearch_freshstart_security.changed | bool
  block:
    - name: Force all notified handlers to run at this point, not waiting for normal sync points
      ansible.builtin.meta: flush_handlers
      tags:
        - certificates
        - renew_ca
        - renew_es_cert

    - name: Wait for all instances to start
      ansible.builtin.include_tasks: wait_for_instance.yml
      loop: "{{ groups[elasticstack_elasticsearch_group_name] }}"
      tags:
        - certificates
        - renew_ca
        - renew_es_cert

- name: Check for passwords being set
  ansible.builtin.stat:
    path: "{{ elasticstack_initial_passwords }}"
  delegate_to: "{{ elasticstack_ca_host }}"
  register: elasticsearch_passwords_file

- name: Setting elasticsearch_http_protocol
  ansible.builtin.set_fact:
    elasticsearch_http_protocol: "https"
  when: elasticsearch_http_security

- name: Check for API with bootstrap password
  ansible.builtin.uri:
    url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}"
    user: elastic
    password: "{{ elasticsearch_bootstrap_pw }}"
    validate_certs: false
  register: elasticsearch_api_status_bootstrap
  changed_when: false
  no_log: "{{ elasticstack_no_log }}"
  when:
    - not elasticsearch_passwords_file.stat.exists | bool
    - groups[elasticstack_elasticsearch_group_name] | length > 1
  until: elasticsearch_api_status_bootstrap.json.cluster_name is defined
  retries: 5
  delay: 10

# We need this check twice. One to wait for the API to be actually available. And a second time to
# check the actual return code. Should not cause a huge delay.

- name: Check for cluster status with bootstrap password
  ansible.builtin.uri:
    url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}/_cluster/health?pretty"
    user: elastic
    password: "{{ elasticsearch_bootstrap_pw }}"
    validate_certs: false
  register: elasticsearch_cluster_status_bootstrap
  changed_when: false
  no_log: "{{ elasticstack_no_log }}"
  when:
    - not elasticsearch_passwords_file.stat.exists | bool
    - groups[elasticstack_elasticsearch_group_name] | length > 1
  until: elasticsearch_cluster_status_bootstrap.json.status in ["green", "yellow"]
  retries: 5
  delay: 10

- name: Fetch Elastic password
  ansible.builtin.include_tasks:
    file: "{{ role_path }}/../elasticstack/tasks/fetch_password.yml"
  vars:
    _password_user: elastic
    _password_fact: elasticstack_password
  when: elasticsearch_passwords_file.stat.exists | bool

- name: Check for API availability with elastic password
  ansible.builtin.uri:
    url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}"
    user: elastic
    password: "{{ elasticstack_password.stdout }}"
    validate_certs: false
  register: elasticsearch_api_status
  changed_when: false
  no_log: "{{ elasticstack_no_log }}"
  when:
    - elasticsearch_passwords_file.stat.exists | bool
    - groups[elasticstack_elasticsearch_group_name] | length > 1
  until: elasticsearch_api_status.json.cluster_name is defined
  retries: 20
  delay: 10

- name: Work around low ressources on CI/CD nodes
  when: ansible_virtualization_type == "container" or ansible_virtualization_type == "docker"
  block:
    # Free up some space to let elsticsearch allocate replica in GitHub Action
    - name: Remove cache
      ansible.builtin.command: >
        rm -rf /var/cache/*
      changed_when: false

    - name: Set persistent watermarks to very high values in Docker
      ansible.builtin.uri:
        url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}/_cluster/settings"
        method: PUT
        body:
          persistent:
            cluster.routing.allocation.disk.watermark.low: "97%"
            cluster.routing.allocation.disk.watermark.high: "98%"
            cluster.routing.allocation.disk.watermark.flood_stage: "99%"
            cluster.routing.allocation.disk.watermark.flood_stage.frozen: "99%"
        body_format: json
        user: elastic
        password: "{{ elasticstack_password.stdout }}"
        validate_certs: false
      changed_when: false
      no_log: "{{ elasticstack_no_log }}"
      when:
        - elasticstack_password.stdout is defined

# We need this check twice. One to wait for the API to be actually available. And a second time to
# check the actual return code. Should not cause a huge delay.

- name: Check for cluster status with elastic password
  ansible.builtin.uri:
    url: "{{ elasticsearch_http_protocol }}://{{ elasticsearch_api_host }}:{{ elasticstack_elasticsearch_http_port }}/_cluster/health?pretty"
    user: elastic
    password: "{{ elasticstack_password.stdout }}"
    validate_certs: false
  register: elasticsearch_cluster_status
  changed_when: false
  no_log: "{{ elasticstack_no_log }}"
  when:
    - elasticsearch_passwords_file.stat.exists | bool
    - groups[elasticstack_elasticsearch_group_name] | length > 1
  until: (elasticsearch_cluster_status.json.status | default('')) in ['green', 'yellow']
  retries: 20
  delay: 10

- name: Leave a file showing that the cluster is set up
  ansible.builtin.template:
    dest: "{{ elasticsearch_initialized_file }}"
    src: elasticsearch_initialized.j2
    owner: root
    group: root
    mode: "0600"

- name: Set var that cluster is set up
  ansible.builtin.set_fact:
    elasticsearch_cluster_set_up: true

- name: Create initial passwords
  ansible.builtin.shell: >
    set -o pipefail;
    /usr/share/elasticsearch/bin/elasticsearch-setup-passwords auto -b >
    {{ elasticstack_initial_passwords }}
  args:
    executable: /bin/bash
    creates: "{{ elasticstack_initial_passwords }}"
  when: inventory_hostname == elasticstack_ca_host
  no_log: "{{ elasticstack_no_log }}"

# It would be better to create and set the permissions before generating the passwords. But this would
# break the logic that relies on the file being absent when no passwords are set
- name: Set permissions on passwords file
  ansible.builtin.file:
    path: "{{ elasticstack_initial_passwords }}"
    owner: root
    group: root
    mode: 0600
  when: inventory_hostname == elasticstack_ca_host

# Maybe make sure that Elasticsearch is using the right protocol http(s) to connect, even in newly setup clusters
